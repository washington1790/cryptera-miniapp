import { Address, Slice, Cell, Dictionary, ExtraCurrency } from "@ton/core";
export declare function configParseMasterAddress(slice: Slice | null | undefined): Address | null;
export type ValidatorSet = {
    timeSince: number;
    timeUntil: number;
    total: number;
    main: number;
    totalWeight: bigint | null;
    list: Dictionary<number, {
        publicKey: Buffer;
        weight: bigint;
        adnlAddress: Buffer | null;
    }>;
};
export declare function parseValidatorSet(slice: Slice): ValidatorSet | null;
export type BridgeParams = {
    bridgeAddress: Address;
    oracleMultisigAddress: Address;
    oracles: Map<string, Buffer>;
    externalChainAddress: Buffer;
};
export declare function parseBridge(slice: Slice): BridgeParams;
export declare function configParseMasterAddressRequired(slice: Slice | null | undefined): Address;
export declare function configParse5(slice: Slice | null | undefined): {
    blackholeAddr: Address | null;
    feeBurnNominator: number;
    feeBurnDenominator: number;
};
export declare function configParse6(slice: Slice | null | undefined): {
    mintNewPrice: bigint;
    mintAddPrice: bigint;
} | null;
export declare function configParse7(slice: Slice | null | undefined): {
    toMint: ExtraCurrency;
};
export declare function configParse9(slice: Slice | null | undefined): Set<number>;
export declare function configParse10(slice: Slice | null | undefined): Set<number>;
export declare function configParse13(slice: Slice | null | undefined): {
    deposit: bigint;
    bitPrice: bigint;
    cellPrice: bigint;
};
export declare function configParse14(slice: Slice | null | undefined): {
    masterchainBlockFee: bigint;
    workchainBlockFee: bigint;
};
export declare function configParse15(slice: Slice | null | undefined): {
    validatorsElectedFor: number;
    electorsStartBefore: number;
    electorsEndBefore: number;
    stakeHeldFor: number;
};
export declare function configParse16(slice: Slice | null | undefined): {
    maxValidators: number;
    maxMainValidators: number;
    minValidators: number;
};
export declare function configParse17(slice: Slice | null | undefined): {
    minStake: bigint;
    maxStake: bigint;
    minTotalStake: bigint;
    maxStakeFactor: number;
};
export type StoragePrices = {
    utime_since: number;
    bit_price_ps: bigint;
    cell_price_ps: bigint;
    mc_bit_price_ps: bigint;
    mc_cell_price_ps: bigint;
};
export declare function configParse18(slice: Slice | null | undefined): StoragePrices[];
export declare function configParse8(slice: Slice | null | undefined): {
    version: number;
    capabilities: bigint;
};
export type ValidatorsPunishmentConfig = {
    defaultFlatFine: bigint;
    defaultProportionaFine: bigint;
    severityFlatMult: number;
    severityProportionalMult: number;
    unfunishableInterval: number;
    longInterval: number;
    longFlatMult: number;
    longProportionalMult: number;
    mediumInterval: number;
    mediumFlatMult: number;
    mediumProportionalMult: number;
};
export declare function configParse40(slice: Slice | null | undefined): ValidatorsPunishmentConfig | null;
export declare function configParseWorkchainDescriptor(slice: Slice): WorkchainDescriptor;
export type WcSplitMergeTimings = {
    split_merge_delay: number;
    split_merge_interval: number;
    min_split_merge_interval: number;
    max_split_merge_delay: number;
};
export type WorkchainDescriptor = {
    enabledSince: number;
    actialMinSplit: number;
    min_split: number;
    max_split: number;
    basic: boolean;
    active: boolean;
    accept_msgs: boolean;
    flags: number;
    zerostateRootHash: Buffer;
    zerostateFileHash: Buffer;
    version: number;
    format: {
        vmVersion: number;
        vmMode: bigint;
    };
    workchain_v2?: {
        split_merge_timings: WcSplitMergeTimings;
        persistent_state_split_depth: number;
    };
};
export declare function configParse12(slice: Slice | null | undefined): Dictionary<number, WorkchainDescriptor>;
export declare function configParseValidatorSet(slice: Slice | null | undefined): ValidatorSet | null;
export declare function configParseBridge(slice: Slice | null | undefined): BridgeParams | null;
export type JettonBridgeParamsV0 = {
    bridgeAddress: Address;
    oracleAddress: Address;
    oracles: {
        addr: Address;
        pubkey: Buffer;
    }[];
    flags: number;
    bridgeBurnFee: bigint;
    jettonBridgePrices?: undefined;
    externalChainAddress?: undefined;
};
export type JettonBridgeParamsV1 = {
    bridgeAddress: Address;
    oracleAddress: Address;
    oracles: {
        addr: Address;
        pubkey: Buffer;
    }[];
    flags: number;
    bridgeBurnFee?: undefined;
    jettonBridgePrices: {
        bridgeBurnFee: bigint;
        bridgeMintFee: bigint;
        walletMinTonsForStorage: bigint;
        walletGasConsumption: bigint;
        minterMinTonsForStorage: bigint;
        discoverGasConsumption: bigint;
    };
    externalChainAddress: Buffer;
};
export type JettonBridgeParams = JettonBridgeParamsV0 | JettonBridgeParamsV1;
export declare function loadJettonBridgeParams(slice: Slice | null | undefined): JettonBridgeParams | null;
export type GasLimitsPrices = {
    flatLimit: bigint;
    flatGasPrice: bigint;
    other: {
        gasPrice: bigint;
        gasLimit: bigint;
        specialGasLimit?: bigint;
        gasCredit: bigint;
        blockGasLimit: bigint;
        freezeDueLimit: bigint;
        deleteDueLimit: bigint;
    };
};
export declare function configParseGasLimitsPrices(slice: Slice | null | undefined): GasLimitsPrices;
export type LimitParams = {
    underload: number;
    softLimit: number;
    hardLimit: number;
};
export type BlockLimits = {
    bytes: LimitParams;
    gas: LimitParams;
    ltDelta: LimitParams;
    collatedData?: LimitParams;
    importedMsgQueue?: {
        maxBytes: number;
        maxMsgs: number;
    };
};
export declare function configParseBlockLimits(slice: Slice | null | undefined): BlockLimits;
export type MsgPrices = {
    lumpPrice: bigint;
    bitPrice: bigint;
    cellPrice: bigint;
    ihrPriceFactor: number;
    firstFrac: number;
    nextFrac: number;
};
export declare function configParseMsgPrices(slice: Slice | null | undefined): MsgPrices;
export type CatchainConfigOld = {
    masterCatchainLifetime: number;
    shardCatchainLifetime: number;
    shardValidatorsLifetime: number;
    shardValidatorsCount: number;
    flags?: undefined;
    suffleMasterValidators?: undefined;
};
export type CatchainConfigNew = {
    masterCatchainLifetime: number;
    shardCatchainLifetime: number;
    shardValidatorsLifetime: number;
    shardValidatorsCount: number;
    flags: number;
    suffleMasterValidators: boolean;
};
export type CatchainConfig = CatchainConfigOld | CatchainConfigNew;
export declare function configParse28(slice: Slice | null | undefined): CatchainConfig;
export type ConsensusConfigOld = {
    roundCandidates: number;
    nextCandidateDelay: number;
    consensusTimeout: number;
    fastAttempts: number;
    attemptDuration: number;
    catchainMaxDeps: number;
    maxBlockBytes: number;
    maxColaltedBytes: number;
    flags?: undefined;
    newCatchainIds?: undefined;
    protoVersion?: undefined;
    catchainMaxBlocksCoeff?: undefined;
};
export type ConsensusConfigNew = {
    roundCandidates: number;
    nextCandidateDelay: number;
    consensusTimeout: number;
    fastAttempts: number;
    attemptDuration: number;
    catchainMaxDeps: number;
    maxBlockBytes: number;
    maxColaltedBytes: number;
    flags: number;
    newCatchainIds: boolean;
    protoVersion?: undefined;
    catchainMaxBlocksCoeff?: undefined;
};
export type ConsensusConfigV3 = {
    roundCandidates: number;
    nextCandidateDelay: number;
    consensusTimeout: number;
    fastAttempts: number;
    attemptDuration: number;
    catchainMaxDeps: number;
    maxBlockBytes: number;
    maxColaltedBytes: number;
    flags: number;
    newCatchainIds: boolean;
    protoVersion: number;
    catchainMaxBlocksCoeff?: undefined;
};
export type ConsensusConfigV4 = {
    roundCandidates: number;
    nextCandidateDelay: number;
    consensusTimeout: number;
    fastAttempts: number;
    attemptDuration: number;
    catchainMaxDeps: number;
    maxBlockBytes: number;
    maxColaltedBytes: number;
    flags: number;
    newCatchainIds: boolean;
    protoVersion: number;
    catchainMaxBlocksCoeff: number;
};
export type ConsensusConfig = ConsensusConfigOld | ConsensusConfigNew | ConsensusConfigV3 | ConsensusConfigV4;
export declare function configParse29(slice: Slice | null | undefined): ConsensusConfig;
export declare function configParse31(slice: Slice | null | undefined): Address[];
export declare function configParse44(slice: Slice | null | undefined): {
    addresses: Address[];
    suspendedUntil: number;
};
export declare function configParse45(slice: Slice | null | undefined): {
    hash: Buffer;
    gasUsed: bigint;
}[];
export type ProposalSetup = {
    minTotalRounds: number;
    maxTotalRounds: number;
    minWins: number;
    maxLoses: number;
    minStoreSec: number;
    maxStoreSec: number;
    bitPrice: number;
    cellPrice: number;
};
export declare function parseProposalSetup(slice: Slice): ProposalSetup;
export type VotingSetup = {
    normalParams: ProposalSetup;
    criticalParams: ProposalSetup;
};
export declare function parseVotingSetup(slice: Slice | null | undefined): VotingSetup;
export declare function loadConfigParamById(configBase64: string, id: number): Cell;
export declare function loadConfigParamsAsSlice(configBase64: string): Map<number, Slice>;
export declare function parseFullConfig(configs: Map<number, Slice>): {
    configAddress: Address;
    electorAddress: Address;
    minterAddress: Address | null;
    feeCollectorAddress: Address | null;
    dnsRootAddress: Address | null;
    burningConfig: {
        blackholeAddr: Address | null;
        feeBurnNominator: number;
        feeBurnDenominator: number;
    };
    globalVersion: {
        version: number;
        capabilities: bigint;
    };
    workchains: Dictionary<number, WorkchainDescriptor>;
    voting: VotingSetup;
    validators: {
        minStake: bigint;
        maxStake: bigint;
        minTotalStake: bigint;
        maxStakeFactor: number;
        maxValidators: number;
        maxMainValidators: number;
        minValidators: number;
        validatorsElectedFor: number;
        electorsStartBefore: number;
        electorsEndBefore: number;
        stakeHeldFor: number;
    };
    storagePrices: StoragePrices[];
    gasPrices: {
        masterchain: GasLimitsPrices;
        workchain: GasLimitsPrices;
    };
    msgPrices: {
        masterchain: MsgPrices;
        workchain: MsgPrices;
    };
    validatorSets: {
        prevValidators: ValidatorSet | null;
        prevTempValidators: ValidatorSet | null;
        currentValidators: ValidatorSet | null;
        currentTempValidators: ValidatorSet | null;
        nextValidators: ValidatorSet | null;
        nextTempValidators: ValidatorSet | null;
    };
    validatorsPunish: ValidatorsPunishmentConfig | null;
    bridges: {
        ethereum: BridgeParams | null;
        binance: BridgeParams | null;
        polygon: BridgeParams | null;
    };
    catchain: CatchainConfig;
    consensus: ConsensusConfig;
};
export declare function parseFullerConfig(configs: Map<number, Slice>): {
    configAddress: Address;
    electorAddress: Address;
    minterAddress: Address | null;
    feeCollectorAddress: Address | null;
    dnsRootAddress: Address | null;
    burningConfig: {
        blackholeAddr: Address | null;
        feeBurnNominator: number;
        feeBurnDenominator: number;
    };
    extraCurrenciesMintPrices: {
        mintNewPrice: bigint;
        mintAddPrice: bigint;
    } | null;
    extraCurrencies: {
        toMint: ExtraCurrency;
    };
    globalVersion: {
        version: number;
        capabilities: bigint;
    };
    configMandatoryParams: Set<number>;
    configCriticalParams: Set<number>;
    voting: VotingSetup;
    workchains: Dictionary<number, WorkchainDescriptor>;
    complaintCost: {
        deposit: bigint;
        bitPrice: bigint;
        cellPrice: bigint;
    };
    blockCreationRewards: {
        masterchainBlockFee: bigint;
        workchainBlockFee: bigint;
    };
    validators: {
        minStake: bigint;
        maxStake: bigint;
        minTotalStake: bigint;
        maxStakeFactor: number;
        maxValidators: number;
        maxMainValidators: number;
        minValidators: number;
        validatorsElectedFor: number;
        electorsStartBefore: number;
        electorsEndBefore: number;
        stakeHeldFor: number;
    };
    storagePrices: StoragePrices[];
    gasPrices: {
        masterchain: GasLimitsPrices;
        workchain: GasLimitsPrices;
    };
    blockLimits: {
        masterchain: BlockLimits;
        workchain: BlockLimits;
    };
    msgPrices: {
        masterchain: MsgPrices;
        workchain: MsgPrices;
    };
    catchain: CatchainConfig;
    consensus: ConsensusConfig;
    fundamentalSmcAddr: Address[];
    validatorSets: {
        prevValidators: ValidatorSet | null;
        prevTempValidators: ValidatorSet | null;
        currentValidators: ValidatorSet | null;
        currentTempValidators: ValidatorSet | null;
        nextValidators: ValidatorSet | null;
        nextTempValidators: ValidatorSet | null;
    };
    validatorsPunish: ValidatorsPunishmentConfig | null;
    suspended: {
        addresses: Address[];
        suspendedUntil: number;
    };
    precompiledContracts: {
        hash: Buffer;
        gasUsed: bigint;
    }[];
    bridges: {
        ethereum: BridgeParams | null;
        binance: BridgeParams | null;
        polygon: BridgeParams | null;
    };
    tokenBridges: {
        ethereum: JettonBridgeParams | null;
        binance: JettonBridgeParams | null;
        polygon: JettonBridgeParams | null;
    };
};
